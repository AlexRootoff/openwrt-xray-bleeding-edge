diff --git a/app/pprof/config.pb.go b/app/pprof/config.pb.go
new file mode 100644
index 0000000..0f5a622
--- /dev/null
+++ b/app/pprof/config.pb.go
@@ -0,0 +1,148 @@
+// Code generated by protoc-gen-go. DO NOT EDIT.
+// versions:
+// 	protoc-gen-go v1.25.0-devel
+// 	protoc        v3.11.4
+// source: app/pprof/config.proto
+
+package pprof
+
+import (
+	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
+	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
+	reflect "reflect"
+	sync "sync"
+)
+
+const (
+	// Verify that this generated code is sufficiently up-to-date.
+	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
+	// Verify that runtime/protoimpl is sufficiently up-to-date.
+	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
+)
+
+// Config is the settings for pprof.
+type Config struct {
+	state         protoimpl.MessageState
+	sizeCache     protoimpl.SizeCache
+	unknownFields protoimpl.UnknownFields
+
+	// Tag of the outbound handler that handles pprof http connections.
+	Tag string `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
+}
+
+func (x *Config) Reset() {
+	*x = Config{}
+	if protoimpl.UnsafeEnabled {
+		mi := &file_app_pprof_config_proto_msgTypes[0]
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		ms.StoreMessageInfo(mi)
+	}
+}
+
+func (x *Config) String() string {
+	return protoimpl.X.MessageStringOf(x)
+}
+
+func (*Config) ProtoMessage() {}
+
+func (x *Config) ProtoReflect() protoreflect.Message {
+	mi := &file_app_pprof_config_proto_msgTypes[0]
+	if protoimpl.UnsafeEnabled && x != nil {
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		if ms.LoadMessageInfo() == nil {
+			ms.StoreMessageInfo(mi)
+		}
+		return ms
+	}
+	return mi.MessageOf(x)
+}
+
+// Deprecated: Use Config.ProtoReflect.Descriptor instead.
+func (*Config) Descriptor() ([]byte, []int) {
+	return file_app_pprof_config_proto_rawDescGZIP(), []int{0}
+}
+
+func (x *Config) GetTag() string {
+	if x != nil {
+		return x.Tag
+	}
+	return ""
+}
+
+var File_app_pprof_config_proto protoreflect.FileDescriptor
+
+var file_app_pprof_config_proto_rawDesc = []byte{
+	0x0a, 0x16, 0x61, 0x70, 0x70, 0x2f, 0x70, 0x70, 0x72, 0x6f, 0x66, 0x2f, 0x63, 0x6f, 0x6e, 0x66,
+	0x69, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x78, 0x72, 0x61, 0x79, 0x2e, 0x61,
+	0x70, 0x70, 0x2e, 0x70, 0x70, 0x72, 0x6f, 0x66, 0x22, 0x1a, 0x0a, 0x06, 0x43, 0x6f, 0x6e, 0x66,
+	0x69, 0x67, 0x12, 0x10, 0x0a, 0x03, 0x74, 0x61, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
+	0x03, 0x74, 0x61, 0x67, 0x42, 0x4c, 0x0a, 0x12, 0x63, 0x6f, 0x6d, 0x2e, 0x78, 0x72, 0x61, 0x79,
+	0x2e, 0x61, 0x70, 0x70, 0x2e, 0x70, 0x70, 0x72, 0x6f, 0x66, 0x50, 0x01, 0x5a, 0x23, 0x67, 0x69,
+	0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x78, 0x74, 0x6c, 0x73, 0x2f, 0x78, 0x72,
+	0x61, 0x79, 0x2d, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x61, 0x70, 0x70, 0x2f, 0x70, 0x70, 0x72, 0x6f,
+	0x66, 0xaa, 0x02, 0x0e, 0x58, 0x72, 0x61, 0x79, 0x2e, 0x41, 0x70, 0x70, 0x2e, 0x50, 0x70, 0x72,
+	0x6f, 0x66, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
+}
+
+var (
+	file_app_pprof_config_proto_rawDescOnce sync.Once
+	file_app_pprof_config_proto_rawDescData = file_app_pprof_config_proto_rawDesc
+)
+
+func file_app_pprof_config_proto_rawDescGZIP() []byte {
+	file_app_pprof_config_proto_rawDescOnce.Do(func() {
+		file_app_pprof_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_app_pprof_config_proto_rawDescData)
+	})
+	return file_app_pprof_config_proto_rawDescData
+}
+
+var file_app_pprof_config_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
+var file_app_pprof_config_proto_goTypes = []interface{}{
+	(*Config)(nil), // 0: xray.app.pprof.Config
+}
+var file_app_pprof_config_proto_depIdxs = []int32{
+	0, // [0:0] is the sub-list for method output_type
+	0, // [0:0] is the sub-list for method input_type
+	0, // [0:0] is the sub-list for extension type_name
+	0, // [0:0] is the sub-list for extension extendee
+	0, // [0:0] is the sub-list for field type_name
+}
+
+func init() { file_app_pprof_config_proto_init() }
+func file_app_pprof_config_proto_init() {
+	if File_app_pprof_config_proto != nil {
+		return
+	}
+	if !protoimpl.UnsafeEnabled {
+		file_app_pprof_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
+			switch v := v.(*Config); i {
+			case 0:
+				return &v.state
+			case 1:
+				return &v.sizeCache
+			case 2:
+				return &v.unknownFields
+			default:
+				return nil
+			}
+		}
+	}
+	type x struct{}
+	out := protoimpl.TypeBuilder{
+		File: protoimpl.DescBuilder{
+			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
+			RawDescriptor: file_app_pprof_config_proto_rawDesc,
+			NumEnums:      0,
+			NumMessages:   1,
+			NumExtensions: 0,
+			NumServices:   0,
+		},
+		GoTypes:           file_app_pprof_config_proto_goTypes,
+		DependencyIndexes: file_app_pprof_config_proto_depIdxs,
+		MessageInfos:      file_app_pprof_config_proto_msgTypes,
+	}.Build()
+	File_app_pprof_config_proto = out.File
+	file_app_pprof_config_proto_rawDesc = nil
+	file_app_pprof_config_proto_goTypes = nil
+	file_app_pprof_config_proto_depIdxs = nil
+}
diff --git a/app/pprof/config.proto b/app/pprof/config.proto
new file mode 100644
index 0000000..0a1975d
--- /dev/null
+++ b/app/pprof/config.proto
@@ -0,0 +1,13 @@
+syntax = "proto3";
+
+package xray.app.pprof;
+option csharp_namespace = "Xray.App.Pprof";
+option go_package = "github.com/xtls/xray-core/app/pprof";
+option java_package = "com.xray.app.pprof";
+option java_multiple_files = true;
+
+// Config is the settings for pprof.
+message Config {
+  // Tag of the outbound handler that handles pprof http connections.
+  string tag = 1;
+}
\ No newline at end of file
diff --git a/app/pprof/errors.generated.go b/app/pprof/errors.generated.go
new file mode 100644
index 0000000..006ef85
--- /dev/null
+++ b/app/pprof/errors.generated.go
@@ -0,0 +1,9 @@
+package pprof
+
+import "github.com/xtls/xray-core/common/errors"
+
+type errPathObjHolder struct{}
+
+func newError(values ...interface{}) *errors.Error {
+	return errors.New(values...).WithPathObj(errPathObjHolder{})
+}
diff --git a/app/pprof/outbound.go b/app/pprof/outbound.go
new file mode 100644
index 0000000..447c5ce
--- /dev/null
+++ b/app/pprof/outbound.go
@@ -0,0 +1,109 @@
+package pprof
+
+import (
+	"context"
+	"sync"
+
+	"github.com/xtls/xray-core/common"
+	"github.com/xtls/xray-core/common/net"
+	"github.com/xtls/xray-core/common/net/cnc"
+	"github.com/xtls/xray-core/common/signal/done"
+	"github.com/xtls/xray-core/transport"
+)
+
+// OutboundListener is a net.Listener for listening pprof http connections.
+type OutboundListener struct {
+	buffer chan net.Conn
+	done   *done.Instance
+}
+
+func (l *OutboundListener) add(conn net.Conn) {
+	select {
+	case l.buffer <- conn:
+	case <-l.done.Wait():
+		conn.Close()
+	default:
+		conn.Close()
+	}
+}
+
+// Accept implements net.Listener.
+func (l *OutboundListener) Accept() (net.Conn, error) {
+	select {
+	case <-l.done.Wait():
+		return nil, newError("listen closed")
+	case c := <-l.buffer:
+		return c, nil
+	}
+}
+
+// Close implement net.Listener.
+func (l *OutboundListener) Close() error {
+	common.Must(l.done.Close())
+L:
+	for {
+		select {
+		case c := <-l.buffer:
+			c.Close()
+		default:
+			break L
+		}
+	}
+	return nil
+}
+
+// Addr implements net.Listener.
+func (l *OutboundListener) Addr() net.Addr {
+	return &net.TCPAddr{
+		IP:   net.IP{0, 0, 0, 0},
+		Port: 0,
+	}
+}
+
+// Outbound is a outbound.Handler that handles pprof http connections.
+type Outbound struct {
+	tag      string
+	listener *OutboundListener
+	access   sync.RWMutex
+	closed   bool
+}
+
+// Dispatch implements outbound.Handler.
+func (co *Outbound) Dispatch(ctx context.Context, link *transport.Link) {
+	co.access.RLock()
+
+	if co.closed {
+		common.Interrupt(link.Reader)
+		common.Interrupt(link.Writer)
+		co.access.RUnlock()
+		return
+	}
+
+	closeSignal := done.New()
+	c := cnc.NewConnection(cnc.ConnectionInputMulti(link.Writer), cnc.ConnectionOutputMulti(link.Reader), cnc.ConnectionOnClose(closeSignal))
+	co.listener.add(c)
+	co.access.RUnlock()
+	<-closeSignal.Wait()
+}
+
+// Tag implements outbound.Handler.
+func (co *Outbound) Tag() string {
+	return co.tag
+}
+
+// Start implements common.Runnable.
+func (co *Outbound) Start() error {
+	co.access.Lock()
+	co.closed = false
+	co.access.Unlock()
+	return nil
+}
+
+// Close implements common.Closable.
+func (co *Outbound) Close() error {
+	co.access.Lock()
+	defer co.access.Unlock()
+
+	co.closed = true
+	return co.listener.Close()
+}
diff --git a/app/pprof/pprof.go b/app/pprof/pprof.go
new file mode 100644
index 0000000..e39ad2d
--- /dev/null
+++ b/app/pprof/pprof.go
@@ -0,0 +1,65 @@
+package pprof
+
+import (
+	"context"
+	"net/http"
+	_ "net/http/pprof"
+
+	"github.com/xtls/xray-core/common"
+	"github.com/xtls/xray-core/common/net"
+	"github.com/xtls/xray-core/common/signal/done"
+	"github.com/xtls/xray-core/core"
+	"github.com/xtls/xray-core/features/outbound"
+)
+
+type PprofHandler struct {
+	ohm outbound.Manager
+	tag string
+}
+
+// NewPprofHandler creates a new PprofHandler based on the given config.
+func NewPprofHandler(ctx context.Context, config *Config) (*PprofHandler, error) {
+	c := &PprofHandler{
+		tag: config.Tag,
+	}
+	common.Must(core.RequireFeatures(ctx, func(om outbound.Manager) {
+		c.ohm = om
+	}))
+	return c, nil
+}
+
+func (p *PprofHandler) Type() interface{} {
+	return (*PprofHandler)(nil)
+}
+
+func (p *PprofHandler) Start() error {
+	listener := &OutboundListener{
+		buffer: make(chan net.Conn, 4),
+		done:   done.New(),
+	}
+
+	go func() {
+		if err := http.Serve(listener, http.DefaultServeMux); err != nil {
+			newError("failed to start pprof server").Base(err).AtError().WriteToLog()
+		}
+	}()
+
+	if err := p.ohm.RemoveHandler(context.Background(), p.tag); err != nil {
+		newError("failed to remove existing handler").WriteToLog()
+	}
+
+	return p.ohm.AddHandler(context.Background(), &Outbound{
+		tag:      p.tag,
+		listener: listener,
+	})
+}
+
+func (p *PprofHandler) Close() error {
+	return nil
+}
+
+func init() {
+	common.Must(common.RegisterConfig((*Config)(nil), func(ctx context.Context, cfg interface{}) (interface{}, error) {
+		return NewPprofHandler(ctx, cfg.(*Config))
+	}))
+}
diff --git a/infra/conf/pprof.go b/infra/conf/pprof.go
new file mode 100644
index 0000000..16d8021
--- /dev/null
+++ b/infra/conf/pprof.go
@@ -0,0 +1,19 @@
+package conf
+
+import (
+	"github.com/xtls/xray-core/app/pprof"
+)
+
+type PprofConfig struct {
+	Tag string `json:"tag"`
+}
+
+func (c *PprofConfig) Build() (*pprof.Config, error) {
+	if c.Tag == "" {
+		return nil, newError("pprof tag can't be empty.")
+	}
+
+	return &pprof.Config{
+		Tag: c.Tag,
+	}, nil
+}
diff --git a/infra/conf/xray.go b/infra/conf/xray.go
index e21018a..c97f233 100644
--- a/infra/conf/xray.go
+++ b/infra/conf/xray.go
@@ -367,6 +367,7 @@ type Config struct {
 	Transport       *TransportConfig       `json:"transport"`
 	Policy          *PolicyConfig          `json:"policy"`
 	API             *APIConfig             `json:"api"`
+	Pprof           *PprofConfig           `json:"pprof"`
 	Stats           *StatsConfig           `json:"stats"`
 	Reverse         *ReverseConfig         `json:"reverse"`
 }
@@ -415,6 +416,9 @@ func (c *Config) Override(o *Config, fn string) {
 	if o.API != nil {
 		c.API = o.API
 	}
+	if o.Pprof != nil {
+		c.Pprof = o.Pprof
+	}
 	if o.Stats != nil {
 		c.Stats = o.Stats
 	}
@@ -509,6 +513,14 @@ func (c *Config) Build() (*core.Config, error) {
 		config.App = append(config.App, serial.ToTypedMessage(apiConf))
 	}
 
+	if c.Pprof != nil {
+		pprofConf, err := c.Pprof.Build()
+		if err != nil {
+			return nil, err
+		}
+		config.App = append(config.App, serial.ToTypedMessage(pprofConf))
+	}
+
 	if c.Stats != nil {
 		statsConf, err := c.Stats.Build()
 		if err != nil {
diff --git a/main/distro/all/all.go b/main/distro/all/all.go
index 68e36e5..7ee6bc1 100644
--- a/main/distro/all/all.go
+++ b/main/distro/all/all.go
@@ -18,6 +18,7 @@ import (
 	_ "github.com/xtls/xray-core/app/dns"
 	_ "github.com/xtls/xray-core/app/log"
 	_ "github.com/xtls/xray-core/app/policy"
+	_ "github.com/xtls/xray-core/app/pprof"
 	_ "github.com/xtls/xray-core/app/reverse"
 	_ "github.com/xtls/xray-core/app/router"
 	_ "github.com/xtls/xray-core/app/stats"
diff --git a/testing/scenarios/pprof_test.go b/testing/scenarios/pprof_test.go
new file mode 100644
index 0000000..3079c2b
--- /dev/null
+++ b/testing/scenarios/pprof_test.go
@@ -0,0 +1,89 @@
+package scenarios
+
+import (
+	"fmt"
+	"io/ioutil"
+	"net/http"
+	"testing"
+
+	"github.com/xtls/xray-core/app/pprof"
+	"github.com/xtls/xray-core/app/proxyman"
+	"github.com/xtls/xray-core/app/router"
+	"github.com/xtls/xray-core/common"
+	"github.com/xtls/xray-core/common/net"
+	"github.com/xtls/xray-core/common/serial"
+	"github.com/xtls/xray-core/core"
+	"github.com/xtls/xray-core/proxy/dokodemo"
+	"github.com/xtls/xray-core/proxy/freedom"
+	"github.com/xtls/xray-core/testing/servers/tcp"
+)
+
+const expectedMessage = "goroutine profile: total"
+
+func TestPprof(t *testing.T) {
+	tcpServer := tcp.Server{
+		MsgProcessor: xor,
+	}
+	dest, err := tcpServer.Start()
+	common.Must(err)
+	defer tcpServer.Close()
+
+	pprofPort := tcp.PickPort()
+	clientConfig := &core.Config{
+		App: []*serial.TypedMessage{
+			serial.ToTypedMessage(&pprof.Config{
+				Tag: "pprof",
+			}),
+			serial.ToTypedMessage(&router.Config{
+				Rule: []*router.RoutingRule{
+					{
+						InboundTag: []string{"pprof"},
+						TargetTag: &router.RoutingRule_Tag{
+							Tag: "pprof",
+						},
+					},
+				},
+			}),
+		},
+		Inbound: []*core.InboundHandlerConfig{
+			{
+				Tag: "pprof",
+				ReceiverSettings: serial.ToTypedMessage(&proxyman.ReceiverConfig{
+					PortRange: net.SinglePortRange(pprofPort),
+					Listen:    net.NewIPOrDomain(net.LocalHostIP),
+				}),
+				ProxySettings: serial.ToTypedMessage(&dokodemo.Config{
+					Address:  net.NewIPOrDomain(dest.Address),
+					Port:     uint32(dest.Port),
+					Networks: []net.Network{net.Network_TCP},
+				}),
+			},
+		},
+		Outbound: []*core.OutboundHandlerConfig{
+			{
+				Tag:           "default-outbound",
+				ProxySettings: serial.ToTypedMessage(&freedom.Config{}),
+			},
+		},
+	}
+
+	servers, err := InitializeServerConfigs(clientConfig)
+	common.Must(err)
+	defer CloseAllServers(servers)
+
+	resp, err := http.Get(fmt.Sprintf("http://127.0.0.1:%d/debug/pprof/goroutine?debug=1", pprofPort))
+	common.Must(err)
+	if resp == nil {
+		t.Error("unexpected nil response")
+	}
+	if resp.StatusCode != http.StatusOK {
+		t.Error("unexpected pprof status code")
+	}
+	body, err := ioutil.ReadAll(resp.Body)
+	if err != nil {
+		t.Fatal(err)
+	}
+	if string(body)[0:len(expectedMessage)] != expectedMessage {
+		t.Error("unexpected response body from pprof handler")
+	}
+}
